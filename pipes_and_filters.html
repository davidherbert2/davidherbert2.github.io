<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="last-modified" content="2021-06-28 09:34:41 +0000">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- meta "search-domain" used for google site search function google_search() -->
    <meta name="search-domain" value="https://swcarpentry.github.io/shell-novice">
    <link rel="stylesheet" type="text/css" href="https://swcarpentry.github.io/shell-novice/assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="https://swcarpentry.github.io/shell-novice/assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="https://swcarpentry.github.io/shell-novice/assets/css/lesson.css" />
    <link rel="stylesheet" type="text/css" href="https://swcarpentry.github.io/shell-novice/assets/css/syntax.css" />

    



    <!-- Favicons for everyone -->
    <link rel="apple-touch-icon-precomposed" sizes="57x57" href="https://swcarpentry.github.io/shell-novice/assets/favicons/swc/apple-touch-icon-57x57.png" />
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="https://swcarpentry.github.io/shell-novice/assets/favicons/swc/apple-touch-icon-114x114.png" />
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://swcarpentry.github.io/shell-novice/assets/favicons/swc/apple-touch-icon-72x72.png" />
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://swcarpentry.github.io/shell-novice/assets/favicons/swc/apple-touch-icon-144x144.png" />
    <link rel="apple-touch-icon-precomposed" sizes="60x60" href="https://swcarpentry.github.io/shell-novice/assets/favicons/swc/apple-touch-icon-60x60.png" />
    <link rel="apple-touch-icon-precomposed" sizes="120x120" href="https://swcarpentry.github.io/shell-novice/assets/favicons/swc/apple-touch-icon-120x120.png" />
    <link rel="apple-touch-icon-precomposed" sizes="76x76" href="https://swcarpentry.github.io/shell-novice/assets/favicons/swc/apple-touch-icon-76x76.png" />
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="https://swcarpentry.github.io/shell-novice/assets/favicons/swc/apple-touch-icon-152x152.png" />
    <link rel="icon" type="image/png" href="https://swcarpentry.github.io/shell-novice/assets/favicons/swc/favicon-196x196.png" sizes="196x196" />
    <link rel="icon" type="image/png" href="https://swcarpentry.github.io/shell-novice/assets/favicons/swc/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/png" href="https://swcarpentry.github.io/shell-novice/assets/favicons/swc/favicon-32x32.png" sizes="32x32" />
    <link rel="icon" type="image/png" href="https://swcarpentry.github.io/shell-novice/assets/favicons/swc/favicon-16x16.png" sizes="16x16" />
    <link rel="icon" type="image/png" href="https://swcarpentry.github.io/shell-novice/assets/favicons/swc/favicon-128.png" sizes="128x128" />
    <meta name="application-name" content="Software Carpentry - The Unix Shell"/>
    <meta name="msapplication-TileColor" content="#FFFFFF" />
    <meta name="msapplication-TileImage" content="https://swcarpentry.github.io/shell-novice/assets/favicons/swc/mstile-144x144.png" />
    <meta name="msapplication-square70x70logo" content="https://swcarpentry.github.io/shell-novice/assets/favicons/swc/mstile-70x70.png" />
    <meta name="msapplication-square150x150logo" content="https://swcarpentry.github.io/shell-novice/assets/favicons/swc/mstile-150x150.png" />
    <meta name="msapplication-wide310x150logo" content="https://swcarpentry.github.io/shell-novice/assets/favicons/swc/mstile-310x150.png" />
    <meta name="msapplication-square310x310logo" content="https://swcarpentry.github.io/shell-novice/assets/favicons/swc/mstile-310x310.png" />


    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
	<script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
	<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
	<![endif]-->

  <title>
  Pipes and Filters &ndash; The Unix Shell
  </title>  
  </head>
  <body>

    <div class="container">

<h1 class="maintitle">Pipes and Filters - Exercises</h1>

<article>

<blockquote class="challenge">
  <h2 id="what-does-sort--n-do">What Does <code class="language-plaintext highlighter-rouge">sort -n</code> Do?</h2>

  <p>If we run <code class="language-plaintext highlighter-rouge">sort</code> on a file containing the following lines:</p>

  <div class="language-plaintext source highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10
2
19
22
6
</code></pre></div>  </div>

  <p>the output is:</p>

  <div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10
19
2
22
6
</code></pre></div>  </div>

  <p>If we run <code class="language-plaintext highlighter-rouge">sort -n</code> on the same input, we get this instead:</p>

  <div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2
6
10
19
22
</code></pre></div>  </div>

  <p>Explain why <code class="language-plaintext highlighter-rouge">-n</code> has this effect.</p>

  <blockquote class="solution">
    <h2 id="solution">Solution</h2>
    <p>The <code class="language-plaintext highlighter-rouge">-n</code> option specifies a numerical rather than an alphanumerical sort.</p>
  </blockquote>
</blockquote>

<blockquote class="challenge">
  <h2 id="what-does--mean">What Does <code class="language-plaintext highlighter-rouge">&gt;&gt;</code> Mean?</h2>

  <p>We have seen the use of <code class="language-plaintext highlighter-rouge">&gt;</code>, but there is a similar operator <code class="language-plaintext highlighter-rouge">&gt;&gt;</code> which works slightly differently.
We’ll learn about the differences between these two operators by printing some strings.
We can use the <code class="language-plaintext highlighter-rouge">echo</code> command to print strings e.g.</p>

  <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">echo </span>The <span class="nb">echo command </span>prints text
</code></pre></div>  </div>
  <div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The echo command prints text
</code></pre></div>  </div>

  <p>Now test the commands below to reveal the difference between the two operators:</p>

  <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">echo </span>hello <span class="o">&gt;</span> testfile01.txt
</code></pre></div>  </div>

  <p>and:</p>

  <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">echo </span>hello <span class="o">&gt;&gt;</span> testfile02.txt
</code></pre></div>  </div>

  <p>Hint: Try executing each command twice in a row and then examining the output files.</p>

  <blockquote class="solution">
    <h2 id="solution-1">Solution</h2>
    <p>In the first example with <code class="language-plaintext highlighter-rouge">&gt;</code>, the string ‘hello’ is written to <code class="language-plaintext highlighter-rouge">testfile01.txt</code>,
but the file gets overwritten each time we run the command.</p>

    <p>We see from the second example that the <code class="language-plaintext highlighter-rouge">&gt;&gt;</code> operator also writes ‘hello’ to a file
(in this case<code class="language-plaintext highlighter-rouge">testfile02.txt</code>),
but appends the string to the file if it already exists (i.e. when we run it for the second time).</p>
  </blockquote>
</blockquote>

<blockquote class="challenge">
  <h2 id="appending-data">Appending Data</h2>

  <p>We have already met the <code class="language-plaintext highlighter-rouge">head</code> command, which prints lines from the start of a file.
<code class="language-plaintext highlighter-rouge">tail</code> is similar, but prints lines from the end of a file instead.</p>

  <p>Consider the file <code class="language-plaintext highlighter-rouge">shell-lesson-data/data/animals.txt</code>.
After these commands, select the answer that
corresponds to the file <code class="language-plaintext highlighter-rouge">animals-subset.txt</code>:</p>

  <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">head</span> <span class="nt">-n</span> 3 animals.txt <span class="o">&gt;</span> animals-subset.txt
<span class="nv">$ </span><span class="nb">tail</span> <span class="nt">-n</span> 2 animals.txt <span class="o">&gt;&gt;</span> animals-subset.txt
</code></pre></div>  </div>

  <ol>
    <li>The first three lines of <code class="language-plaintext highlighter-rouge">animals.txt</code></li>
    <li>The last two lines of <code class="language-plaintext highlighter-rouge">animals.txt</code></li>
    <li>The first three lines and the last two lines of <code class="language-plaintext highlighter-rouge">animals.txt</code></li>
    <li>The second and third lines of <code class="language-plaintext highlighter-rouge">animals.txt</code></li>
  </ol>

  <blockquote class="solution">
    <h2 id="solution-2">Solution</h2>
    <p>Option 3 is correct.
For option 1 to be correct we would only run the <code class="language-plaintext highlighter-rouge">head</code> command.
For option 2 to be correct we would only run the <code class="language-plaintext highlighter-rouge">tail</code> command.
For option 4 to be correct we would have to pipe the output of <code class="language-plaintext highlighter-rouge">head</code> into <code class="language-plaintext highlighter-rouge">tail -n 2</code> by doing <code class="language-plaintext highlighter-rouge">head -n 3 animals.txt | tail -n 2 &gt; animals-subset.txt</code></p>
  </blockquote>
</blockquote>


<blockquote class="challenge">
  <h2 id="piping-commands-together">Piping Commands Together</h2>

  <p>In our current directory, we want to find the 3 files which have the least number of
lines. Which command listed below would work?</p>

  <ol>
    <li><code class="language-plaintext highlighter-rouge">wc -l * &gt; sort -n &gt; head -n 3</code></li>
    <li><code class="language-plaintext highlighter-rouge">wc -l * | sort -n | head -n 1-3</code></li>
    <li><code class="language-plaintext highlighter-rouge">wc -l * | head -n 3 | sort -n</code></li>
    <li><code class="language-plaintext highlighter-rouge">wc -l * | sort -n | head -n 3</code></li>
  </ol>

  <blockquote class="solution">
    <h2 id="solution-3">Solution</h2>
    <p>Option 4 is the solution.
The pipe character <code class="language-plaintext highlighter-rouge">|</code> is used to connect the output from one command to
the input of another.
<code class="language-plaintext highlighter-rouge">&gt;</code> is used to redirect standard output to a file.
Try it in the <code class="language-plaintext highlighter-rouge">shell-lesson-data/molecules</code> directory!</p>
  </blockquote>
</blockquote>

<blockquote class="challenge">
  <h2 id="pipe-reading-comprehension">Pipe Reading Comprehension</h2>

  <p>A file called <code class="language-plaintext highlighter-rouge">animals.txt</code> (in the <code class="language-plaintext highlighter-rouge">shell-lesson-data/data</code> folder) contains the following data:</p>

  <div class="language-plaintext source highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2012-11-05,deer
2012-11-05,rabbit
2012-11-05,raccoon
2012-11-06,rabbit
2012-11-06,deer
2012-11-06,fox
2012-11-07,rabbit
2012-11-07,bear
</code></pre></div>  </div>

  <p>What text passes through each of the pipes and the final redirect in the pipeline below?</p>

  <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat </span>animals.txt | <span class="nb">head</span> <span class="nt">-n</span> 5 | <span class="nb">tail</span> <span class="nt">-n</span> 3 | <span class="nb">sort</span> <span class="nt">-r</span> <span class="o">&gt;</span> final.txt
</code></pre></div>  </div>
  <p>Hint: build the pipeline up one command at a time to test your understanding</p>
  <blockquote class="solution">
    <h2 id="solution-4">Solution</h2>
    <p>The <code class="language-plaintext highlighter-rouge">head</code> command extracts the first 5 lines from <code class="language-plaintext highlighter-rouge">animals.txt</code>.
Then, the last 3 lines are extracted from the previous 5 by using the <code class="language-plaintext highlighter-rouge">tail</code> command.
With the <code class="language-plaintext highlighter-rouge">sort -r</code> command those 3 lines are sorted in reverse order and finally,
the output is redirected to a file <code class="language-plaintext highlighter-rouge">final.txt</code>.
The content of this file can be checked by executing <code class="language-plaintext highlighter-rouge">cat final.txt</code>.
The file should contain the following lines:</p>
    <div class="language-plaintext source highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2012-11-06,rabbit
2012-11-06,deer
2012-11-05,raccoon
</code></pre></div>    </div>
  </blockquote>
</blockquote>

<blockquote class="challenge">
  <h2 id="pipe-construction">Pipe Construction</h2>

  <p>For the file <code class="language-plaintext highlighter-rouge">animals.txt</code> from the previous exercise, consider the following command:</p>

  <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cut</span> <span class="nt">-d</span> , <span class="nt">-f</span> 2 animals.txt
</code></pre></div>  </div>

  <p>The <code class="language-plaintext highlighter-rouge">cut</code> command is used to remove or ‘cut out’ certain sections of each line in the file,
and <code class="language-plaintext highlighter-rouge">cut</code> expects the lines to be separated into columns by a <kbd>Tab</kbd> character.
A character used in this way is a called a <strong>delimiter</strong>.
In the example above we use the <code class="language-plaintext highlighter-rouge">-d</code> option to specify the comma as our delimiter character.
We have also used the <code class="language-plaintext highlighter-rouge">-f</code> option to specify that we want to extract the second field (column).
This gives the following output:</p>

  <div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>deer
rabbit
raccoon
rabbit
deer
fox
rabbit
bear
</code></pre></div>  </div>

  <p>The <code class="language-plaintext highlighter-rouge">uniq</code> command filters out adjacent matching lines in a file.
How could you extend this pipeline (using <code class="language-plaintext highlighter-rouge">uniq</code> and another command) to find
out what animals the file contains (without any duplicates in their
names)?</p>

  <blockquote class="solution">
    <h2 id="solution-5">Solution</h2>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cut</span> <span class="nt">-d</span> , <span class="nt">-f</span> 2 animals.txt | <span class="nb">sort</span> | <span class="nb">uniq</span>
</code></pre></div>    </div>
  </blockquote>
</blockquote>

<blockquote class="challenge">
  <h2 id="which-pipe">Which Pipe?</h2>

  <p>The file <code class="language-plaintext highlighter-rouge">animals.txt</code> contains 8 lines of data formatted as follows:</p>

  <div class="language-plaintext output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2012-11-05,deer
2012-11-05,rabbit
2012-11-05,raccoon
2012-11-06,rabbit
...
</code></pre></div>  </div>

  <p>The <code class="language-plaintext highlighter-rouge">uniq</code> command has a <code class="language-plaintext highlighter-rouge">-c</code> option which gives a count of the
number of times a line occurs in its input.  Assuming your current
directory is <code class="language-plaintext highlighter-rouge">shell-lesson-data/data/</code>, what command would you use to produce
a table that shows the total count of each type of animal in the file?</p>

  <ol>
    <li><code class="language-plaintext highlighter-rouge">sort animals.txt | uniq -c</code></li>
    <li><code class="language-plaintext highlighter-rouge">sort -t, -k2,2 animals.txt | uniq -c</code></li>
    <li><code class="language-plaintext highlighter-rouge">cut -d, -f 2 animals.txt | uniq -c</code></li>
    <li><code class="language-plaintext highlighter-rouge">cut -d, -f 2 animals.txt | sort | uniq -c</code></li>
    <li><code class="language-plaintext highlighter-rouge">cut -d, -f 2 animals.txt | sort | uniq -c | wc -l</code></li>
  </ol>

  <blockquote class="solution">
    <h2 id="solution-6">Solution</h2>
    <p>Option 4. is the correct answer.
If you have difficulty understanding why, try running the commands, or sub-sections of
the pipelines (make sure you are in the <code class="language-plaintext highlighter-rouge">shell-lesson-data/data</code> directory).</p>
  </blockquote>
</blockquote>

<blockquote class="challenge">
  <h2 id="wildcard-expressions">Wildcard Expressions</h2>

  <p>Wildcard expressions can be very complex, but you can sometimes write
them in ways that only use simple syntax, at the expense of being a bit
more verbose.
Consider the directory <code class="language-plaintext highlighter-rouge">shell-lesson-data/north-pacific-gyre/2012-07-03</code> :
the wildcard expression <code class="language-plaintext highlighter-rouge">*[AB].txt</code>
matches all files ending in <code class="language-plaintext highlighter-rouge">A.txt</code> or <code class="language-plaintext highlighter-rouge">B.txt</code>. Imagine you forgot about
this.</p>

  <ol>
    <li>
      <p>Can you match the same set of files with basic wildcard expressions
that do not use the <code class="language-plaintext highlighter-rouge">[]</code> syntax? <em>Hint</em>: You may need more than one
command, or two arguments to the <code class="language-plaintext highlighter-rouge">ls</code> command.</p>
    </li>
    <li>
      <p>If you used two commands, the files in your output will match the
same set of files in this example. What is the small difference between the
outputs?</p>
    </li>
    <li>
      <p>If you used two commands, under what circumstances would your new
expression produce an error message where the original one would not?</p>
    </li>
  </ol>

  <blockquote class="solution">
    <h2 id="solution-7">Solution</h2>
    <ol>
      <li>A solution using two wildcard commands:
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ ls *A.txt
 $ ls *B.txt
</code></pre></div>        </div>
        <p>A solution using one command but with two arguments:</p>
        <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nv">$ </span><span class="nb">ls</span> <span class="k">*</span>A.txt <span class="k">*</span>B.txt
</code></pre></div>        </div>
      </li>
      <li>The output from the two new commands is separated because there are two commands.</li>
      <li>When there are no files ending in <code class="language-plaintext highlighter-rouge">A.txt</code>, or there are no files ending in
<code class="language-plaintext highlighter-rouge">B.txt</code>, then one of the two commands will fail.</li>
    </ol>
  </blockquote>
</blockquote>

<blockquote class="challenge">
  <h2 id="removing-unneeded-files">Removing Unneeded Files</h2>

  <p>Suppose you want to delete your processed data files, and only keep
your raw files and processing script to save storage.
The raw files end in <code class="language-plaintext highlighter-rouge">.dat</code> and the processed files end in <code class="language-plaintext highlighter-rouge">.txt</code>.
Which of the following would remove all the processed data files,
and <em>only</em> the processed data files?</p>

  <ol>
    <li><code class="language-plaintext highlighter-rouge">rm ?.txt</code></li>
    <li><code class="language-plaintext highlighter-rouge">rm *.txt</code></li>
    <li><code class="language-plaintext highlighter-rouge">rm * .txt</code></li>
    <li><code class="language-plaintext highlighter-rouge">rm *.*</code></li>
  </ol>

  <blockquote class="solution">
    <h2 id="solution-8">Solution</h2>
    <ol>
      <li>This would remove <code class="language-plaintext highlighter-rouge">.txt</code> files with one-character names</li>
      <li>This is correct answer</li>
      <li>The shell would expand <code class="language-plaintext highlighter-rouge">*</code> to match everything in the current directory,
so the command would try to remove all matched files and an additional
file called <code class="language-plaintext highlighter-rouge">.txt</code></li>
      <li>The shell would expand <code class="language-plaintext highlighter-rouge">*.*</code> to match all files with any extension,
so this command would delete all files</li>
    </ol>
  </blockquote>
</blockquote>




</article>
      
    </div>
    
<script src="https://swcarpentry.github.io/shell-novice/assets/js/jquery.min.js"></script>
<script src="https://swcarpentry.github.io/shell-novice/assets/js/bootstrap.min.js"></script>
<script src="https://swcarpentry.github.io/shell-novice/assets/js/lesson.js"></script>

  </body>
</html>
